"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const plugin_1 = require("../../plugin");
const relative_url_1 = require("./relative-url");
const brackets = /\[\[([^\]]+)\]\]/g;
const urlPrefix = /^(http|ftp)s?:\/\//;
const inlineTag = /(?:\[(.+?)\])?\{@(link|linkcode|linkplain)\s+((?:.|\n)+?)\}/gi;
function comment() {
    const includePattern = /\[\[include:([^\]]+?)\]\]/g;
    const mediaPattern = /media:\/\/([^ "\)\]\}]+)/g;
    let text = this;
    if (plugin_1.MarkdownPlugin.settings && plugin_1.MarkdownPlugin.settings.includes) {
        text = text.replace(includePattern, (match, pathString) => {
            pathString = path.join(plugin_1.MarkdownPlugin.settings.includes, pathString.trim());
            if (fs.existsSync(pathString) && fs.statSync(pathString).isFile()) {
                return fs.readFileSync(pathString, 'utf-8');
            }
            return '';
        });
    }
    if (plugin_1.MarkdownPlugin.settings && plugin_1.MarkdownPlugin.settings.media) {
        text = text.replace(mediaPattern, (match, pathString) => {
            if (fs.existsSync(path.join(plugin_1.MarkdownPlugin.settings.media, pathString))) {
                return relative_url_1.relativeUrl(`media/${pathString}`);
            }
            return match;
        });
    }
    text = replaceInlineTags(replaceBrackets(text));
    return text;
}
exports.comment = comment;
function replaceBrackets(text) {
    return text.replace(brackets, (match, content) => {
        const split = splitLinkText(content);
        return buildLink(match, split.target, split.caption);
    });
}
function splitLinkText(text) {
    let splitIndex = text.indexOf('|');
    if (splitIndex === -1) {
        splitIndex = text.search(/\s/);
    }
    if (splitIndex !== -1) {
        return {
            caption: text.substr(splitIndex + 1).replace(/\n+/, ' '),
            target: text.substr(0, splitIndex),
        };
    }
    else {
        return {
            caption: text,
            target: text,
        };
    }
}
function replaceInlineTags(text) {
    return text.replace(inlineTag, (match, leading, tagName, content) => {
        const split = splitLinkText(content);
        const target = split.target;
        const caption = leading || split.caption;
        return buildLink(match, target, caption);
    });
}
function buildLink(original, target, caption) {
    let reflection;
    if (urlPrefix.test(target)) {
        return target;
    }
    if (plugin_1.MarkdownPlugin.reflection) {
        reflection = plugin_1.MarkdownPlugin.reflection.findReflectionByName(target);
    }
    else if (plugin_1.MarkdownPlugin.project) {
        reflection = plugin_1.MarkdownPlugin.project.findReflectionByName(target);
    }
    if (reflection && reflection.url) {
        if (urlPrefix.test(reflection.url)) {
            target = reflection.url;
        }
        else {
            target = relative_url_1.relativeUrl(reflection.url);
        }
    }
    else {
        return original;
    }
    return `[${caption}](${target})`;
}
